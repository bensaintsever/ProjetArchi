\documentclass[11pt,a4paper]{report}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}  
\usepackage[french]{babel}
\usepackage{url}
\usepackage{graphicx}
\usepackage{fancyhdr}
\pagestyle{fancy}
\usepackage{listings}


\title{Rapport de projet : Architecture des ordinateurs}
\author{Benjamin Saint-Sever, Steven Ratton}
\date{\today}

\renewcommand{\headrulewidth}{1pt}
\fancyhead[R]{Rapport de Projet}

\renewcommand{\footrulewidth}{1pt}
\fancyfoot[L]{Rapport de projet}


\begin{document}

\maketitle

\tableofcontents





\chapter{Introduction}
Le but de ce projet est de montrer la possibilité d'extension de l'architecture y86, en ajoutant des instructions et en manipulant les prédictions de branchement. Ce projet a pour vocation de nous enseigner la programmation de langage machine tout en tirant parti au mieux des capacités des ordinateurs. 

%EXERCICE 1
\chapter {Exercice 1}
\section{implémentation de leal}
\paragraph{Description\\}

Le but de ce premier exercice est de créer une nouvelle instruction "leal" pour "load effective address", cette derniere est existante sous l'architecture x86. Cette instruction charge l'adresse de la source dans dest ( leal (\%regS),\%regD). On souhaite que cette instruction permette un déplacement mémoire, leal depl(\%regS),regD. L'avantage de cette solution est que l'on peut effectuer cette opération avec une seule instruction. Son equivalent est : "rrmovl \%regS,\%regD ; iaddl depl,\%regD"
\newline

\paragraph{Assembleur\\}
Il est possible d'ajouter cette instruction sans consommer un nouvel opcode, il suffit de reprendre le formalisme de irmovl est de donner une valeur de ifun différente afin de faire la distinction (ifun =1).

Premiere étapes, on insère dans le code assembleur la déclaration de cette nouvelle instruction : 

\begin{enumerate}
\item isa.c
\begin{lstlisting}
   instr_t instruction_set[] = 
{
/*Ajout de leal avec iFun a 1*/
{"leal", HPACK(I_IRMOVL, 1), 6, M_ARG, 1, 0, R_ARG, 1, 1 },
\end{lstlisting}


\item yas-grammar.lex
\begin{lstlisting}
Instr         leal|rrmovl|rmmovl|mrmovl|irmovl|
\end{lstlisting}
\end{enumerate}

\newpage
\paragraph{Fichier test\_leal.ys : \\}

On déplace de 8 à partir de l'adresse du registre \%eax et on attribue l'adresse dans le registre \%ebx :

\begin{lstlisting}
 irmovl 3, %eax
        leal 8(%eax), %ebx
        halt
\end{lstlisting}

\paragraph{Code HCL : \\}
On ajoute le code d'instruction irmovl pour identifier leal:
\begin{lstlisting}
intsig LEAL     'I_IRMOVL'
\end{lstlisting}
\newpage

\section{Architecture séquentielle}
\paragraph{Etape FETCH : \\}On ne modifie rien puisque l'on interprète le même fonctionnement que l'instruction irmovl.
\paragraph{Etape Decode :\\}le contenue du registre 'B' (Source) est attribué à la source A.
\begin{lstlisting}
int srcA = [
        #icode vaut irmovl ou leal, pour obtenir leal -> ifun=1
        (icode == LEAL) && (ifun == 1):rB;
];
\end{lstlisting}
le contenue du registre 'A' est attribué à la E destination afin d'écrire la nouvelle adresse de destination.
\begin{lstlisting}
int dstE = [
        (icode == IRMOVL) && (ifun == 0) : rB;
        (icode == LEAL) && (ifun == 1) : rA;
];
\end{lstlisting}

\paragraph{Etape Execute : \\} 
On place ValC dans l'aluA et ValA dans l'aluB, cela permettre d'effectuer le calcul de déplacement :
\begin{lstlisting}
int aluA = [
        (icode == IRMOVL) && (ifun == 0) : valC;  
        (icode == LEAL) && (ifun == 1): valC;
	#Deux lignes pour la lisibilité mais on peut aussi
	 utiliser seulement icode in {irmovl} : valC
];
int aluB = [
        (icode == IRMOVL) && (ifun == 0) : 0;
        (icode == LEAL) && (ifun == 1): valA;
];

\end{lstlisting}

%IMAGES
\begin{figure}[h!]
  \centering 
  \includegraphics[height=9.5cm]{leal.png}
  \caption{Fetch}
\end{figure}

\begin{figure}[h!]
  \centering 
  \includegraphics[height=9cm]{valeurleal.png}
  \caption{Decode}
\end{figure}
\clearpage
\newpage


%PIPELINE
\section{Architecture pipe\-lines}
Afin de pouvoir identifier la bonne instruction à l'étage Decode il est nécessaire de récupérer la valeur de ifun qui permettra de différencier irmovl de leal, on ajoute donc la déclaration suivante :
\begin{lstlisting}
intsig D_ifun 'if_id_curr->ifun'	# Instruction function
\end{lstlisting}

La prise en compte de leal dans la hcl pipeline diffère peut de l'architecture séquentielle, il faut néanmoins prendre en compte le ifun et icode des étages concerner.
 
\paragraph{Etape Decode : \\} 
Meme chose que pour l'architecture seq :
\begin{lstlisting}
int new_E_srcA = [
	D_icode in { RRMOVL, RMMOVL, OPL, PUSHL } : D_rA;
	(D_icode == IRMOVL && D_ifun == 1) : D_rB;
	D_icode in { POPL, RET } : RESP;
	1 : RNONE; # Don't need register
];

int new_E_dstE = [
	D_icode in { RRMOVL, OPL, IOPL } : D_rB;
	D_icode in { PUSHL, POPL, CALL, RET } : RESP;
	(D_icode == IRMOVL && D_ifun == 1) : D_rA;
	(D_icode == IRMOVL && D_ifun == 0) : D_rB;
	1 : DNONE;  # Don't need register DNONE, not RNONE
];
\end{lstlisting}

\paragraph{Etape Execute : \\}
Dans l'ALUA on utilise valC donc on ne modifie rien.
\begin{lstlisting}
int aluA = [
	E_icode in { IRMOVL, RMMOVL, MRMOVL, IOPL } : E_valC;
];
\end{lstlisting}
Dans l'ALUB on souhaite utiliser valA, IRMOVL n'utilise rien donc il utilise la condition qui suis.
\begin{lstlisting}
int aluB = [
	(E_icode == IRMOVL && E_ifun == 1) : E_valA;
	E_icode in { RRMOVL, IRMOVL } : 0;
	# Other instructions don't need ALU
];
\end{lstlisting}
\newpage
eax vaut 3, on ajoute 8 à l'adresse de ce dernier et on stocke le résultat de dans ebx
\begin{figure}[h!]
  \centering 
  \includegraphics[height = 5cm]{lealDecodePipe.png}
  \caption{Decode}
\end{figure}

\begin{figure}[h!]
  \centering 
    \includegraphics[height=5cm]{lealExePipe.png}
  \caption{Execute}
\end{figure}

\begin{figure}[h!]
  \centering 
    \includegraphics[height=1.5cm]{lealWBPipe.png}
  \caption{Write Back}
\end{figure}

\begin{figure}[h!]
  \centering 
    \includegraphics[height=1.5cm]{lealFinPipe.png}
  \caption{Résultat}
\end{figure}


%EXERCICE 2
\chapter{Exercice 2}


\end{document}