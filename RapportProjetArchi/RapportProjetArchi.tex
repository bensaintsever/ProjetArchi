\documentclass[11pt,a4paper]{report}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}  
\usepackage[french]{babel}
\usepackage{url}
\usepackage{graphicx}
\usepackage{fancyhdr}
\pagestyle{fancy}
\usepackage{listings}


\title{Rapport de projet : Architecture des ordinateurs}
\author{Benjamin Saint-Sever, Steven Ratton}
\date{\today}

\renewcommand{\headrulewidth}{1pt}
\fancyhead[R]{Rapport de Projet}

\renewcommand{\footrulewidth}{1pt}
\fancyfoot[L]{Rapport de projet}


\begin{document}

\maketitle

\tableofcontents





\chapter{Introduction}
Le but de ce projet est de montrer la possibilité d'extension de l'architecture y86, en ajoutant des instructions et en manipulant les prédictions de branchement. Ce projet a pour vocation de nous enseigner la programmation de langage machine tout en tirant parti au mieux des capacités des ordinateurs. 

%EXERCICE 1
\chapter {Exercice 1 : Ajout de l'instruction leal}
\section{implémentation de leal}
\paragraph{Description\\}

Le but de ce premier exercice est de créer une nouvelle instruction "leal" pour "load effective address", cette derniere est existante sous l'architecture x86. Cette instruction charge l'adresse de la source dans dest ( leal (\%regS),\%regD). On souhaite que cette instruction permette un déplacement mémoire, leal depl(\%regS),regD. L'avantage de cette solution est que l'on peut effectuer cette opération avec une seule instruction. Son equivalent est : "rrmovl \%regS,\%regD ; iaddl depl,\%regD"
\newline

\paragraph{Assembleur\\}
Il est possible d'ajouter cette instruction sans consommer un nouvel opcode, il suffit de reprendre le formalisme de irmovl est de donner une valeur de ifun différente afin de faire la distinction (ifun =1).

Premiere étapes, on insère dans le code assembleur la déclaration de cette nouvelle instruction : 

\begin{enumerate}
\item isa.c
\begin{lstlisting}
   instr_t instruction_set[] = 
{
/*Ajout de leal avec iFun a 1*/
{"leal", HPACK(I_IRMOVL, 1), 6, M_ARG, 1, 0, R_ARG, 1, 1 },
\end{lstlisting}


\item yas-grammar.lex
\begin{lstlisting}
Instr         leal|rrmovl|rmmovl|mrmovl|irmovl|
\end{lstlisting}
\end{enumerate}

\newpage
\paragraph{Fichier test\_leal.ys : \\}

On déplace de 8 à partir de l'adresse du registre \%eax et on attribue l'adresse dans le registre \%ebx :

\begin{lstlisting}
 irmovl 3, %eax
        leal 8(%eax), %ebx
        halt
\end{lstlisting}


\section{Architecture séquentielle}
\paragraph{Code HCL : \\}
On ajoute le code d'instruction irmovl pour identifier leal:
\begin{lstlisting}
intsig LEAL     'I_IRMOVL'
\end{lstlisting}


\paragraph{Etape FETCH : \\}On ne modifie rien puisque l'on interprète le même fonctionnement que l'instruction irmovl.
\paragraph{Etape Decode :\\}le contenue du registre 'B' (Source) est attribué à la source A.
\begin{lstlisting}
int srcA = [
        #icode vaut irmovl ou leal, pour obtenir leal -> ifun=1
        (icode == LEAL) && (ifun == 1):rB;
];
\end{lstlisting}
le contenue du registre 'A' est attribué à la E destination afin d'écrire la nouvelle adresse de destination.
\begin{lstlisting}
int dstE = [
        (icode == IRMOVL) && (ifun == 0) : rB;
        (icode == LEAL) && (ifun == 1) : rA;
];
\end{lstlisting}

\paragraph{Etape Execute : \\} 
On place ValC dans l'aluA et ValA dans l'aluB, cela permettre d'effectuer le calcul de déplacement :
\begin{lstlisting}
int aluA = [
        (icode == IRMOVL) && (ifun == 0) : valC;  
        (icode == LEAL) && (ifun == 1): valC;
	#Deux lignes pour la lisibilité mais on peut aussi
	 utiliser seulement icode in {irmovl} : valC
];
int aluB = [
        (icode == IRMOVL) && (ifun == 0) : 0;
        (icode == LEAL) && (ifun == 1): valA;
];

\end{lstlisting}

%IMAGES
\begin{figure}[h!]
  \centering 
  \includegraphics[height=11cm]{leal.png}
  \caption{Fetch}
\end{figure}

\begin{figure}[h!]
  \centering 
  \includegraphics[height=15cm]{valeurleal.png}
  \caption{Decode}
\end{figure}
\clearpage
\newpage


%PIPELINE
\section{Architecture pipe\-lines}
Afin de pouvoir identifier la bonne instruction à l'étage Decode il est nécessaire de récupérer la valeur de ifun qui permettra de différencier irmovl de leal, on ajoute donc la déclaration suivante :
\begin{lstlisting}
intsig D_ifun 'if_id_curr->ifun'	# Instruction function
\end{lstlisting}

La prise en compte de leal dans la hcl pipeline diffère peut de l'architecture séquentielle, il faut néanmoins prendre en compte le ifun et icode des étages concerner.
 
\paragraph{Etape Decode : \\} 
Meme chose que pour l'architecture seq :
\begin{lstlisting}
int new_E_srcA = [
	D_icode in { RRMOVL, RMMOVL, OPL, PUSHL } : D_rA;
	(D_icode == IRMOVL && D_ifun == 1) : D_rB;
	D_icode in { POPL, RET } : RESP;
	1 : RNONE; # Don't need register
];

int new_E_dstE = [
	D_icode in { RRMOVL, OPL, IOPL } : D_rB;
	D_icode in { PUSHL, POPL, CALL, RET } : RESP;
	(D_icode == IRMOVL && D_ifun == 1) : D_rA;
	(D_icode == IRMOVL && D_ifun == 0) : D_rB;
	1 : DNONE;  # Don't need register DNONE, not RNONE
];
\end{lstlisting}

\paragraph{Etape Execute : \\}
Dans l'ALUA on utilise valC donc on ne modifie rien.
\begin{lstlisting}
int aluA = [
	E_icode in { IRMOVL, RMMOVL, MRMOVL, IOPL } : E_valC;
];
\end{lstlisting}
Dans l'ALUB on souhaite utiliser valA, IRMOVL n'utilise rien donc il utilise la condition qui suis.
\begin{lstlisting}
int aluB = [
	(E_icode == IRMOVL && E_ifun == 1) : E_valA;
	E_icode in { RRMOVL, IRMOVL } : 0;
	# Other instructions don't need ALU
];
\end{lstlisting}
\newpage
eax vaut 3, on ajoute 8 à l'adresse de ce dernier et on stocke le résultat de dans ebx
\begin{figure}[h!]
  \centering 
  \includegraphics[height = 5cm]{lealDecodePipe.png}
  \caption{Decode}
\end{figure}

\begin{figure}[h!]
  \centering 
    \includegraphics[height=5cm]{lealExePipe.png}
  \caption{Execute}
\end{figure}

\begin{figure}[h!]
  \centering 
    \includegraphics[height=1.5cm]{lealWBPipe.png}
  \caption{Write Back}
\end{figure}

\begin{figure}[h!]
  \centering 
    \includegraphics[height=1.5cm]{lealFinPipe.png}
  \caption{Résultat}
\end{figure}


%EXERCICE 2
\chapter{Exercice 2 : Mise en \oe{}uvre de stratégies de prédiction statique}

Gestion des versions:
- nouveau fichier "pipe-maversion1.hcl"
- changer la variable VERSION dans le fichier Makefile


Analyse du CPI:
- ajout des fichiers test loop.ys et cpi.ys
- make loop.yo et make cpi.yo
- ./psim -g loop.yo et  ./psim -g cpi.yo


\paragraph{Question 1: Expliquer pourquoi on perd du temps avec la prédiction de branchement actuelle de type « toujours ».\\}

On perd du temps avec la prédiction de branchement actuelle de type « toujours » car le nombre de cycles est plus important que le nombre d'instructions réalisées, du au fait que la condition est toujours vraie sauf en sortie de boucle. pour le cpi.yo on a :
\begin{figure}[h!]
  \centering 
    \includegraphics[height=1.25cm]{BouclesCPI.jpg}
\end{figure}


La prédiction de branchement est une fonctionnalité d'un processeur qui lui permet de prédire le résultat d'un branchement. Cette technique permet à un processeur de rendre l'utilisation de son pipeline plus efficace. Avec cette technique, le processeur va faire de l'exécution spéculative : il va parier sur le résultat d'un branchement, et va poursuivre l'exécution du programme avec le résultat du pari. Si le pari échoue, les instructions chargées par erreur dans le pipeline sont annulées.


- valC utilisé comme adresse de la prochaine instruction.
- valP conservé le long du pipe-line pour devenir l'adresse de la prochaine instruction si la prédiction s'avère fausse (valP est multiplexé en tant que valA dès l'étage E).


Prédiction de branchement "jamais":
Il se pourra que ce soit valP qui serve d'adresse de la prochaine instruction, et il faudra alors préserver valC.
=> propager valC également jusqu'à l'étage M, en plus de valP/valA.

%Instructions pour lesquelles on ne peut connaître l'adresse de la prochaine instruction :%Jxx : adresse connue après l'étage E On a le choix entre deux adresses%RET : adresse connue après l'étage M%RET : adresse connue après l'étage M%On ne peut absolument rien prédire
\begin{lstlisting}
ajout : intsig JUNCOND 'J_YES'


on utilise alors "(M_icode == JXX) && (M_ifun!= JUNCOND)" 
pour les tests.
\end{lstlisting}

\end{document}